<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Simple Packet Tracer</title>
    <style>
        body {
            font-family: monospace;
            background-color: #111;
            color: #0f0;
            padding: 20px;
        }
        .log-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        #log, #nodeLog {
            flex: 1;
            white-space: pre-wrap;
            background: #000;
            padding: 1em;
            border-radius: 8px;
            max-height: 70vh;
            overflow-y: auto;
        }
        select, input, button {
            margin-right: 10px;
            margin-top: 10px;
            padding: 4px;
        }
    </style>
</head>
<body>
<h2>📡 실시간 패킷 로그</h2>

<!-- 인터페이스 선택 -->
<button onclick="loadInterfaces()">인터페이스 조회</button>
<select id="interfaceSelect">
    <option disabled selected>인터페이스 선택</option>
</select>

<!-- 필터 입력 -->
<input type="text" id="filterInput" placeholder="ex: tcp, udp, port 53" />
<button onclick="startCapture()">캡처 시작</button>

<!-- 로그 출력 영역을 좌우 배치 -->
<div class="log-container">
    <div id="log"></div>
    <div id="nodeLog"></div>
</div>


<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

<script>
    let socket;

    function loadInterfaces() {
        fetch("http://localhost:8081/interface")
            .then(res => {
                if (!res.ok) throw new Error(`응답 오류 (${res.status})`);
                return res.json();
            })
            .then(data => {
                const select = document.getElementById("interfaceSelect");
                select.innerHTML = '<option disabled selected>인터페이스 선택</option>';
                data.forEach((iface) => {
                    const option = document.createElement("option");
                    option.value = iface.split(" : ")[0];
                    option.textContent = iface;
                    select.appendChild(option);
                });
                log("✅ 인터페이스 목록 로딩 완료");
            })
            .catch(err => {
                log("❌ 인터페이스 조회 실패: " + err.message);
            });
    }

    function startCapture() {
        const selectedInterface = document.getElementById("interfaceSelect").value;
        const filter = document.getElementById("filterInput").value;

        if (!selectedInterface) {
            alert("인터페이스를 선택해주세요.");
            return;
        }

        // 기존 로그 초기화
        document.getElementById("log").innerHTML = "";

        // 캡처 요청
        fetch(`http://localhost:8081/capture?interfaceName=${encodeURIComponent(selectedInterface)}&bpfFilter=${encodeURIComponent(filter)}`)
            .then(res => {
                if (!res.ok) throw new Error(`캡처 요청 실패 (${res.status})`);
                log("📤 캡처 요청 전송됨. WebSocket 수신 대기 중...");
                openSocket();
            })
            .catch(err => {
                log("❌ 캡처 요청 실패: " + err.message);
            });
    }

    function openSocket() {
        if (socket && socket.readyState !== WebSocket.CLOSED) {
            socket.close();
        }

        socket = new WebSocket("ws://localhost:8081/packets");

        socket.onopen = () => {
            log("✅ WebSocket 연결됨");
        };

        socket.onmessage = (event) => {
            console.log("📥 WebSocket 수신 원본 데이터:", event.data);
            try {
                const data = JSON.parse(event.data);
                const time = new Date().toLocaleTimeString();

                const lines = [`[${time}] 패킷 수신:`];
                // const lines = [`패킷 수신:`];

                const layers = data.layers || {};
                if (layers.Ethernet) {
                    const eth = layers.Ethernet;
                    lines.push(`  🔌 Ethernet`);
                    lines.push(`    SRC MAC: ${eth.srcMac}`);
                    lines.push(`    DST MAC: ${eth.dstMac}`);
                    lines.push(`    TYPE   : ${eth.type}`);
                }

                if (layers.IPv4) {
                    const ip = layers.IPv4;
                    lines.push(`  🌐 IPv4`);
                    lines.push(`    SRC IP : ${ip.srcIp}`);
                    lines.push(`    DST IP : ${ip.dstIp}`);
                    lines.push(`    PROTO  : ${ip.protocol}`);
                }

                if (layers.TCP) {
                    const tcp = layers.TCP;
                    lines.push(`  📦 TCP`);
                    lines.push(`    SRC PORT: ${tcp.srcPort}`);
                    lines.push(`    DST PORT: ${tcp.dstPort}`);
                }

                if (layers.UDP) {
                    const udp = layers.UDP;
                    lines.push(`  📦 UDP`);
                    lines.push(`    SRC PORT: ${udp.srcPort}`);
                    lines.push(`    DST PORT: ${udp.dstPort}`);
                }

                if (layers.ICMP) {
                    const icmp = layers.ICMP;
                    lines.push(`  🛰️ ICMP`);
                    lines.push(`    TYPE: ${icmp.type}`);
                    lines.push(`    CODE: ${icmp.code}`);
                }

                log(lines.join('\n'));
            } catch (e) {
                log(`⚠️ JSON 파싱 실패: ${e.message}\n원본 데이터: ${event.data}`);
            }
        };


        socket.onerror = (e) => log(`🚨 WebSocket 오류`);
        socket.onclose = () => log("❌ WebSocket 연결 종료됨");
    }

    function log(message) {
        const logDiv = document.getElementById("log");

        const entry = document.createElement("pre");
        entry.textContent = message;
        logDiv.appendChild(entry);

        logDiv.scrollTop = logDiv.scrollHeight;
    }

    function logToNode(message) {
        const logDiv = document.getElementById("nodeLog");

        const entry = document.createElement("pre");
        entry.textContent = message;
        logDiv.appendChild(entry);

        logDiv.scrollTop = logDiv.scrollHeight;
    }


    function connectStompForNodeStatus() {
        const sock = new SockJS('http://localhost:8081/ws');
        const stompClient = Stomp.over(sock);

        stompClient.connect({}, function () {
            logToNode("🧠 STOMP 연결 완료: 노드 상태 수신 대기 중...");

            stompClient.subscribe("/topic/nodes/status", function (message) {
                try {
                    const payload = JSON.parse(message.body);
                    if (payload.type === "NODE_STATUS_UPDATED") {
                        const nodes = payload.data;
                        const lines = ["🌐 노드 상태 업데이트"];

                        nodes.forEach(node => {
                            lines.push(`🟢 Node: ${node.nodeId}, 연결 수: ${node.connectionCount}`);
                        });

                        logToNode(lines.join('\n'));  // ✅ 이 부분 중요
                    }
                } catch (e) {
                    logToNode(`⚠️ STOMP 메시지 파싱 실패: ${e.message}`);
                }
            });
        });
    }
    // 페이지 로딩 후 STOMP 연결
    window.addEventListener("load", connectStompForNodeStatus);
</script>
</body>
</html>
