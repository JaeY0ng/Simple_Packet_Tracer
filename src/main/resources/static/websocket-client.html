<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Simple Packet Tracer</title>
    <style>
        body {
            font-family: monospace;
            background-color: #111;
            color: #0f0;
            padding: 20px;
        }
        .log-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        #log, #nodeLog {
            flex: 1;
            white-space: pre-wrap;
            background: #000;
            padding: 1em;
            border-radius: 8px;
            max-height: 70vh;
            overflow-y: auto;
        }
        select, input, button {
            margin-right: 10px;
            margin-top: 10px;
            padding: 4px;
        }
    </style>
</head>
<body>
<h2>ğŸ“¡ ì‹¤ì‹œê°„ íŒ¨í‚· ë¡œê·¸</h2>

<!-- ì¸í„°í˜ì´ìŠ¤ ì„ íƒ -->
<button onclick="loadInterfaces()">ì¸í„°í˜ì´ìŠ¤ ì¡°íšŒ</button>
<select id="interfaceSelect">
    <option disabled selected>ì¸í„°í˜ì´ìŠ¤ ì„ íƒ</option>
</select>

<!-- í•„í„° ì…ë ¥ -->
<input type="text" id="filterInput" placeholder="ex: tcp, udp, port 53" />
<button onclick="startCapture()">ìº¡ì²˜ ì‹œì‘</button>

<h3>ğŸ“¨ Ping ì‹œë®¬ë ˆì´ì…˜</h3>
<input type="text" id="pingSource" placeholder="Source Node ID">
<input type="text" id="pingTarget" placeholder="Target Node ID">
<button onclick="simulatePing()">Ping ìš”ì²­</button>

<!-- í† í´ë¡œì§€ ë³´ê¸° ë²„íŠ¼ -->
<button onclick="loadTopology()">ğŸ” í† í´ë¡œì§€ ë³´ê¸°</button>


<h3>ë…¸ë“œ ì¶”ê°€</h3>
<input type="text" id="newNodeName" placeholder="ë…¸ë“œ ì´ë¦„" />
<input type="text" id="newNodeIp" placeholder="IP ì£¼ì†Œ (ì˜ˆ: 192.168.0.1)" />
<button onclick="addNode()">ë…¸ë“œ ìƒì„±</button>


<!-- ë¡œê·¸ ì¶œë ¥ ì˜ì—­ì„ ì¢Œìš° ë°°ì¹˜ -->
<div class="log-container">
    <div id="log"></div>
    <div id="nodeLog"></div>
</div>


<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

<script>
    let socket;

    function loadInterfaces() {
        fetch("http://localhost:8081/interface")
            .then(res => {
                if (!res.ok) throw new Error(`ì‘ë‹µ ì˜¤ë¥˜ (${res.status})`);
                return res.json();
            })
            .then(data => {
                const select = document.getElementById("interfaceSelect");
                select.innerHTML = '<option disabled selected>ì¸í„°í˜ì´ìŠ¤ ì„ íƒ</option>';
                data.forEach((iface) => {
                    const option = document.createElement("option");
                    option.value = iface.split(" : ")[0];
                    option.textContent = iface;
                    select.appendChild(option);
                });
                log("âœ… ì¸í„°í˜ì´ìŠ¤ ëª©ë¡ ë¡œë”© ì™„ë£Œ");
            })
            .catch(err => {
                log("âŒ ì¸í„°í˜ì´ìŠ¤ ì¡°íšŒ ì‹¤íŒ¨: " + err.message);
            });
    }

    function startCapture() {
        const selectedInterface = document.getElementById("interfaceSelect").value;
        const filter = document.getElementById("filterInput").value;

        if (!selectedInterface) {
            alert("ì¸í„°í˜ì´ìŠ¤ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.");
            return;
        }

        // ê¸°ì¡´ ë¡œê·¸ ì´ˆê¸°í™”
        document.getElementById("log").innerHTML = "";

        // ìº¡ì²˜ ìš”ì²­
        fetch(`http://localhost:8081/capture?interfaceName=${encodeURIComponent(selectedInterface)}&bpfFilter=${encodeURIComponent(filter)}`)
            .then(res => {
                if (!res.ok) throw new Error(`ìº¡ì²˜ ìš”ì²­ ì‹¤íŒ¨ (${res.status})`);
                log("ğŸ“¤ ìº¡ì²˜ ìš”ì²­ ì „ì†¡ë¨. WebSocket ìˆ˜ì‹  ëŒ€ê¸° ì¤‘...");
                openSocket();
            })
            .catch(err => {
                log("âŒ ìº¡ì²˜ ìš”ì²­ ì‹¤íŒ¨: " + err.message);
            });
    }

    function openSocket() {
        if (socket && socket.readyState !== WebSocket.CLOSED) {
            socket.close();
        }

        socket = new WebSocket("ws://localhost:8081/packets");

        socket.onopen = () => {
            log("âœ… WebSocket ì—°ê²°ë¨");
        };

        socket.onmessage = (event) => {
            console.log("ğŸ“¥ WebSocket ìˆ˜ì‹  ì›ë³¸ ë°ì´í„°:", event.data);
            try {
                const data = JSON.parse(event.data);
                const time = new Date().toLocaleTimeString();

                const lines = [`[${time}] íŒ¨í‚· ìˆ˜ì‹ :`];
                // const lines = [`íŒ¨í‚· ìˆ˜ì‹ :`];

                const layers = data.layers || {};
                if (layers.Ethernet) {
                    const eth = layers.Ethernet;
                    lines.push(`  ğŸ”Œ Ethernet`);
                    lines.push(`    SRC MAC: ${eth.srcMac}`);
                    lines.push(`    DST MAC: ${eth.dstMac}`);
                    lines.push(`    TYPE   : ${eth.type}`);
                }

                if (layers.IPv4) {
                    const ip = layers.IPv4;
                    lines.push(`  ğŸŒ IPv4`);
                    lines.push(`    SRC IP : ${ip.srcIp}`);
                    lines.push(`    DST IP : ${ip.dstIp}`);
                    lines.push(`    PROTO  : ${ip.protocol}`);
                }

                if (layers.TCP) {
                    const tcp = layers.TCP;
                    lines.push(`  ğŸ“¦ TCP`);
                    lines.push(`    SRC PORT: ${tcp.srcPort}`);
                    lines.push(`    DST PORT: ${tcp.dstPort}`);
                }

                if (layers.UDP) {
                    const udp = layers.UDP;
                    lines.push(`  ğŸ“¦ UDP`);
                    lines.push(`    SRC PORT: ${udp.srcPort}`);
                    lines.push(`    DST PORT: ${udp.dstPort}`);
                }

                if (layers.ICMP) {
                    const icmp = layers.ICMP;
                    lines.push(`  ğŸ›°ï¸ ICMP`);
                    lines.push(`    TYPE: ${icmp.type}`);
                    lines.push(`    CODE: ${icmp.code}`);
                }

                log(lines.join('\n'));
            } catch (e) {
                log(`âš ï¸ JSON íŒŒì‹± ì‹¤íŒ¨: ${e.message}\nì›ë³¸ ë°ì´í„°: ${event.data}`);
            }
        };


        socket.onerror = (e) => log(`ğŸš¨ WebSocket ì˜¤ë¥˜`);
        socket.onclose = () => log("âŒ WebSocket ì—°ê²° ì¢…ë£Œë¨");
    }

    function log(message) {
        const logDiv = document.getElementById("log");

        const entry = document.createElement("pre");
        entry.textContent = message;
        logDiv.appendChild(entry);

        logDiv.scrollTop = logDiv.scrollHeight;
    }

    function logToNode(message) {
        const logDiv = document.getElementById("nodeLog");

        const entry = document.createElement("pre");
        entry.textContent = message;
        logDiv.appendChild(entry);

        logDiv.scrollTop = logDiv.scrollHeight;
    }


    function connectStompForNodeStatus() {
        const sock = new SockJS('http://localhost:8081/ws');
        const stompClient = Stomp.over(sock);

        stompClient.connect({}, function () {
            logToNode("ğŸ§  STOMP ì—°ê²° ì™„ë£Œ: ë…¸ë“œ ìƒíƒœ ìˆ˜ì‹  ëŒ€ê¸° ì¤‘...");

            stompClient.subscribe("/topic/nodes/status", function (message) {
                try {
                    const payload = JSON.parse(message.body);
                    if (payload.type === "NODE_STATUS_UPDATED") {
                        const nodes = payload.data;
                        const lines = ["ğŸŒ ë…¸ë“œ ìƒíƒœ ì—…ë°ì´íŠ¸"];

                        nodes.forEach(node => {
                            lines.push(`ğŸŸ¢ Node: ${node.nodeId}, ì—°ê²° ìˆ˜: ${node.connectionCount}`);
                        });

                        logToNode(lines.join('\n'));  // âœ… ì´ ë¶€ë¶„ ì¤‘ìš”
                    }
                } catch (e) {
                    logToNode(`âš ï¸ STOMP ë©”ì‹œì§€ íŒŒì‹± ì‹¤íŒ¨: ${e.message}`);
                }
            });
        });
    }
    // í˜ì´ì§€ ë¡œë”© í›„ STOMP ì—°ê²°
    window.addEventListener("load", connectStompForNodeStatus);



    // Ping ìš”ì²­ í•¨ìˆ˜
    function simulatePing() {
        const source = document.getElementById("pingSource").value.trim();
        const target = document.getElementById("pingTarget").value.trim();

        if (!source || !target) {
            alert("Sourceì™€ Target ë…¸ë“œ IDë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            return;
        }

        fetch("http://localhost:8081/api/simulate/ping", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sourceNodeId: source, targetNodeId: target })
        })
            .then(res => {
                if (!res.ok) {
                    return res.text().then(text => {
                        throw new Error(text);
                    })
                }
                return res.json();
            })
            .then(data => {
                const status = data.reachable ? "ì—°ê²°ë¨" : "ì—°ê²°ë˜ì§€ ì•ŠìŒ";
                logToNode(` Ping ê²°ê³¼: ${data.source} â†’ ${data.target} :: ${status}`);
            })
            .catch(err => {
                logToNode(" Ping ì˜¤ë¥˜: " + err.message);
            });
    }

    // í† í´ë¡œì§€ ì¡°íšŒ í•¨ìˆ˜
    function loadTopology() {
        fetch("http://localhost:8081/api/virtual/topology")
            .then(res => res.json())
            .then(data => {
                const lines = [" í˜„ì¬ í† í´ë¡œì§€ ìƒíƒœ"];
                data.nodes.forEach(n => lines.push(`ë…¸ë“œ: ${n.id}, ì´ë¦„: ${n.name}`));
                data.links.forEach(l => lines.push(`ë§í¬: ${l.id}, ${l.nodeAId} â†” ${l.nodeBId}`));
                logToNode(lines.join('\n'));
            })
            .catch(err => logToNode("í† í´ë¡œì§€ ì¡°íšŒ ì‹¤íŒ¨: " + err.message));
    }
</script>
</body>
</html>
