<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Simple Packet Tracer</title>

    <script>
        window.BACKEND_URL = "http://54.180.91.230:8081";
    </script>

    <style>
        body {
            font-family: monospace;
            background-color: #111;
            color: #0f0;
            padding: 20px;
        }
        .log-container {
            display: flex;
            gap: 5px;
            margin-top: 20px;
        }
        #log, #nodeLog {
            flex: 1;
            white-space: pre-wrap;
            background: #000;
            padding: 1em;
            border-radius: 8px;
            max-height: 70vh;
            overflow-y: auto;
        }
        select, input, button {
            margin-right: 5px;
            margin-top: 5px;
            padding: 4px;
        }
    </style>
</head>
<body>
<h3>ğŸ“¡ ì‹¤ì‹œê°„ íŒ¨í‚· ë¡œê·¸</h3>

<!-- ì¸í„°í˜ì´ìŠ¤ ì„ íƒ -->
<button onclick="loadInterfaces()">ì¸í„°í˜ì´ìŠ¤ ì¡°íšŒ</button>
<select id="interfaceSelect">
    <option disabled selected>ì¸í„°í˜ì´ìŠ¤ ì„ íƒ</option>
</select>

<!-- í•„í„° ì…ë ¥ ( ê³µë°±ì€ ì „ì²´ ) -->
<input type="text" id="filterInput" placeholder="ex: tcp, udp, port 53" />
<button onclick="startCapture()">ìº¡ì²˜ ì‹œì‘</button>

<!-- í† í´ë¡œì§€ ë²„íŠ¼ -->
<button onclick="loadTopology()">ğŸ” í† í´ë¡œì§€ ë³´ê¸°</button>

<h3>â• ê°€ìƒ ë…¸ë“œ ì¶”ê°€</h3>
<input type="text" id="newNodeName" placeholder="ë…¸ë“œ ëª…" />
<input type="text" id="newNodeIp" placeholder="IP ì£¼ì†Œ" />
<button onclick="addNode()">ë…¸ë“œ ìƒì„±</button>

<h3>ğŸ“¨ Ping ì‹œë®¬ë ˆì´ì…˜</h3>
<input type="text" id="pingSource" placeholder="Source Node ID">
<input type="text" id="pingTarget" placeholder="Target Node ID">
<button onclick="simulatePing()">Ping ìš”ì²­</button>


<h3>ğŸ—‘ï¸ ë…¸ë“œ ì‚­ì œ</h3>
<input type="text" id="deleteNodeId" placeholder="ë…¸ë“œ ID" />
<button onclick="deleteNode()">ë…¸ë“œ ì‚­ì œ</button>


<h3>ğŸ”— ë§í¬ ìƒì„±</h3>
<input type="text" id="linkA" placeholder="ë…¸ë“œ A ID" />
<input type="text" id="linkB" placeholder="ë…¸ë“œ B ID" />
<button onclick="createLink()">ë§í¬ ìƒì„±</button>


<h3>âŒ ë§í¬ ì‚­ì œ</h3>
<input type="text" id="deleteLinkId" placeholder="ë§í¬ ID" />
<button onclick="deleteLink()">ë§í¬ ì‚­ì œ</button>

<!-- ë¡œê·¸ ì¶œë ¥ ì˜ì—­ì„ ì¢Œìš° ë°°ì¹˜ -->
<div class="log-container">
    <div id="log"></div>
    <div id="nodeLog"></div>
</div>


<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>

<script>
    let socket;

    function loadInterfaces() {
        fetch(`${window.BACKEND_URL}/interface`)
            .then(res => {
                if (!res.ok) throw new Error(`ì‘ë‹µ ì˜¤ë¥˜ (${res.status})`);
                return res.json();
            })
            .then(data => {
                const select = document.getElementById("interfaceSelect");
                select.innerHTML = '<option disabled selected>ì¸í„°í˜ì´ìŠ¤ ì„ íƒ</option>';
                data.forEach((iface) => {
                    const option = document.createElement("option");
                    option.value = iface.split(" : ")[0];
                    option.textContent = iface;
                    select.appendChild(option);
                });
                log("âœ… ì¸í„°í˜ì´ìŠ¤ ëª©ë¡ ë¡œë”© ì™„ë£Œ");
            })
            .catch(err => {
                log("âŒ ì¸í„°í˜ì´ìŠ¤ ì¡°íšŒ ì‹¤íŒ¨: " + err.message);
            });
    }

    function startCapture() {
        const selectedInterface = document.getElementById("interfaceSelect").value;
        const filter = document.getElementById("filterInput").value;

        if (!selectedInterface) {
            alert("ì¸í„°í˜ì´ìŠ¤ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.");
            return;
        }

        // ê¸°ì¡´ ë¡œê·¸ ì´ˆê¸°í™”
        document.getElementById("log").innerHTML = "";

        // ìº¡ì²˜ ìš”ì²­
        fetch(`${window.BACKEND_URL}/capture?interfaceName=${encodeURIComponent(selectedInterface)}&bpfFilter=${encodeURIComponent(filter)}`)
            .then(res => {
                if (!res.ok) throw new Error(`ìº¡ì²˜ ìš”ì²­ ì‹¤íŒ¨ (${res.status})`);
                log("ğŸ“¤ ìº¡ì²˜ ìš”ì²­ ì „ì†¡ë¨. WebSocket ìˆ˜ì‹  ëŒ€ê¸° ì¤‘...");
                openSocket();
            })
            .catch(err => {
                log("âŒ ìº¡ì²˜ ìš”ì²­ ì‹¤íŒ¨: " + err.message);
            });
    }

    function openSocket() {
        if (socket && socket.readyState !== WebSocket.CLOSED) {
            socket.close();
        }

        socket = new WebSocket(`ws://${window.BACKEND_URL.split("://")[1]}/packets`);

        socket.onopen = () => {
            log("âœ… WebSocket ì—°ê²°ë¨");
        };

        socket.onmessage = (event) => {
            console.log("ğŸ“¥ WebSocket ìˆ˜ì‹  ì›ë³¸ ë°ì´í„°:", event.data);
            try {
                const data = JSON.parse(event.data);
                const time = new Date().toLocaleTimeString();

                const lines = [`[${time}] íŒ¨í‚· ìˆ˜ì‹ :`];
                // const lines = [`íŒ¨í‚· ìˆ˜ì‹ :`];

                const layers = data.layers || {};
                if (layers.Ethernet) {
                    const eth = layers.Ethernet;
                    lines.push(`  ğŸ”Œ Ethernet`);
                    lines.push(`    SRC MAC: ${eth.srcMac}`);
                    lines.push(`    DST MAC: ${eth.dstMac}`);
                    lines.push(`    TYPE   : ${eth.type}`);
                }

                if (layers.IPv4) {
                    const ip = layers.IPv4;
                    lines.push(`  ğŸŒ IPv4`);
                    lines.push(`    SRC IP : ${ip.srcIp}`);
                    lines.push(`    DST IP : ${ip.dstIp}`);
                    lines.push(`    PROTO  : ${ip.protocol}`);
                }

                if (layers.TCP) {
                    const tcp = layers.TCP;
                    lines.push(`  ğŸ“¦ TCP`);
                    lines.push(`    SRC PORT: ${tcp.srcPort}`);
                    lines.push(`    DST PORT: ${tcp.dstPort}`);
                }

                if (layers.UDP) {
                    const udp = layers.UDP;
                    lines.push(`  ğŸ“¦ UDP`);
                    lines.push(`    SRC PORT: ${udp.srcPort}`);
                    lines.push(`    DST PORT: ${udp.dstPort}`);
                }

                if (layers.ICMP) {
                    const icmp = layers.ICMP;
                    lines.push(`  ğŸ›°ï¸ ICMP`);
                    lines.push(`    TYPE: ${icmp.type}`);
                    lines.push(`    CODE: ${icmp.code}`);
                }

                log(lines.join('\n'));
            } catch (e) {
                log(`âš ï¸ JSON íŒŒì‹± ì‹¤íŒ¨: ${e.message}\nì›ë³¸ ë°ì´í„°: ${event.data}`);
            }
        };


        socket.onerror = (e) => log(`ğŸš¨ WebSocket ì˜¤ë¥˜`);
        socket.onclose = () => log("âŒ WebSocket ì—°ê²° ì¢…ë£Œë¨");
    }

    function log(message) {
        const logDiv = document.getElementById("log");

        const entry = document.createElement("pre");
        entry.textContent = message;
        logDiv.appendChild(entry);

        logDiv.scrollTop = logDiv.scrollHeight;
    }

    function logToNode(message) {
        const logDiv = document.getElementById("nodeLog");

        const entry = document.createElement("pre");
        entry.textContent = message;
        logDiv.appendChild(entry);

        logDiv.scrollTop = logDiv.scrollHeight;
    }


    function connectStompForNodeStatus() {
        const sock = new SockJS(`${window.BACKEND_URL}/ws`);
        const stompClient = Stomp.over(sock);

        stompClient.connect({}, function () {
            logToNode("ğŸ§  STOMP ì—°ê²° ì™„ë£Œ: ë…¸ë“œ ìƒíƒœ ìˆ˜ì‹  ëŒ€ê¸° ì¤‘...");

            stompClient.subscribe("/topic/nodes/status", function (message) {
                try {
                    const payload = JSON.parse(message.body);
                    if (payload.type === "NODE_STATUS_UPDATED") {
                        const nodes = payload.data;
                        const lines = ["ğŸŒ ë…¸ë“œ ìƒíƒœ ì—…ë°ì´íŠ¸"];

                        nodes.forEach(node => {
                            lines.push(`ğŸŸ¢ Node: ${node.nodeId}, ì—°ê²° ìˆ˜: ${node.connectionCount}`);
                        });

                        logToNode(lines.join('\n'));  // âœ… ì´ ë¶€ë¶„ ì¤‘ìš”
                    }
                } catch (e) {
                    logToNode(`âš ï¸ STOMP ë©”ì‹œì§€ íŒŒì‹± ì‹¤íŒ¨: ${e.message}`);
                }
            });
        });
    }
    // í˜ì´ì§€ ë¡œë”© í›„ STOMP ì—°ê²°
    window.addEventListener("load", connectStompForNodeStatus);



    // Ping ìš”ì²­ í•¨ìˆ˜
    function simulatePing() {
        const source = document.getElementById("pingSource").value.trim();
        const target = document.getElementById("pingTarget").value.trim();

        if (!source || !target) {
            alert("Sourceì™€ Target ë…¸ë“œ IDë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            return;
        }

        fetch(`${window.BACKEND_URL}/api/simulate/ping`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ sourceNodeId: source, targetNodeId: target })
        })
            .then(res => {
                if (!res.ok) {
                    return res.text().then(text => {
                        throw new Error(text);
                    })
                }
                return res.json();
            })
            .then(data => {
                const status = data.reachable ? "ì—°ê²°ë¨" : "ì—°ê²°ë˜ì§€ ì•ŠìŒ";
                logToNode(` Ping ê²°ê³¼: ${data.source} â†’ ${data.target} :: ${status}`);
            })
            .catch(err => {
                logToNode(" Ping ì˜¤ë¥˜: " + err.message);
            });
    }

    // í† í´ë¡œì§€ ì¡°íšŒ í•¨ìˆ˜
    function loadTopology() {
        fetch(`${window.BACKEND_URL}/api/virtual/topology`)
            .then(res => res.json())
            .then(data => {
                const lines = ["ğŸ“‘ í˜„ì¬ í† í´ë¡œì§€ ìƒíƒœ"];
                data.nodes.forEach(n => lines.push(`ë…¸ë“œ: ${n.id}, ì´ë¦„: ${n.name}`));
                data.links.forEach(l => lines.push(`ë§í¬: ${l.id}, ${l.nodeAId} â†” ${l.nodeBId}`));
                logToNode(lines.join('\n'));
            })
            .catch(err => logToNode("â— í† í´ë¡œì§€ ì¡°íšŒ ì‹¤íŒ¨: " + err.message));
    }

    // ê°€ìƒ ë…¸ë“œ ì¶”ê°€
    function addNode() {
        const name = document.getElementById("newNodeName").value.trim();
        const ip = document.getElementById("newNodeIp").value.trim();

        if (!name || !ip) {
            alert("ë…¸ë“œ ì´ë¦„ê³¼ IP ì£¼ì†Œë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            return;
        }

        fetch(`${window.BACKEND_URL}/api/virtual/nodes`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name, ipAddress: ip })
        })
            .then(res => {
                if (!res.ok) throw new Error("â— ë…¸ë“œ ìƒì„± ì‹¤íŒ¨");
                return res.json();
            })
            .then(data => {
                logToNode(`ë…¸ë“œ ìƒì„±ë¨: ID=${data.id}, ì´ë¦„=${data.name}, IP=${data.ipAddress}`);
                loadTopology(); // ìµœì‹  í† í´ë¡œì§€ ê°±ì‹ 
            })
            .catch(err => {
                logToNode("â— ë…¸ë“œ ìƒì„± ì‹¤íŒ¨: " + err.message);
            });
    }

    // ê°€ìƒ ë…¸ë“œ ì‚­ì œ
    function deleteNode() {
        const nodeId = document.getElementById("deleteNodeId").value.trim();
        if (!nodeId) return alert("ë…¸ë“œ IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");

        fetch(`${window.BACKEND_URL}/api/virtual/nodes/${nodeId}`, {
            method: "DELETE"
        })
            .then(res => res.json())
            .then(data => {
                logToNode(`ğŸ—‘ï¸ ${data.message}`);
                loadTopology();
            })
            .catch(err => logToNode("âŒ ë…¸ë“œ ì‚­ì œ ì‹¤íŒ¨: " + err.message));
    }

    // ë§í¬ ìƒì„±
    function createLink() {
        const a = document.getElementById("linkA").value.trim();
        const b = document.getElementById("linkB").value.trim();
        if (!a || !b) return alert("ë‘ ë…¸ë“œ IDë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.");

        fetch(`${window.BACKEND_URL}/api/virtual/links`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ nodeAId: a, nodeBId: b })
        })
            .then(res => res.json())
            .then(data => {
                logToNode(`ğŸ”— ë§í¬ ìƒì„±ë¨: ${data.nodeAId} â†” ${data.nodeBId}`);
                loadTopology();
            })
            .catch(err => logToNode("âŒ ë§í¬ ìƒì„± ì‹¤íŒ¨: " + err.message));
    }

    //ë§í¬ ì‚­ì œ
    function deleteLink() {
        const linkId = document.getElementById("deleteLinkId").value.trim();
        if (!linkId) return alert("ë§í¬ IDë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");

        fetch(`${window.BACKEND_URL}/api/virtual/links/${linkId}`, {
            method: "DELETE"
        })
            .then(() => {
                logToNode(`â­• ë§í¬ ì‚­ì œ ì™„ë£Œ: ${linkId}`);
                loadTopology();
            })
            .catch(err => logToNode("âŒ ë§í¬ ì‚­ì œ ì‹¤íŒ¨: " + err.message));
    }
</script>
</body>
</html>
